<html>
<head>
<title>exceptions.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #629755; font-style: italic;}
.s1 { color: #a9b7c6;}
.s2 { color: #cc7832;}
.s3 { color: #808080;}
.s4 { color: #6a8759;}
.s5 { color: #6897bb;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
exceptions.py</font>
</center></td></tr></table>
<pre><span class="s0">&quot;&quot;&quot;Implements a number of Python exceptions which can be raised from within 
a view to trigger a standard HTTP non-200 response. 
 
Usage Example 
------------- 
 
.. code-block:: python 
 
    from werkzeug.wrappers.request import Request 
    from werkzeug.exceptions import HTTPException, NotFound 
 
    def view(request): 
        raise NotFound() 
 
    @Request.application 
    def application(request): 
        try: 
            return view(request) 
        except HTTPException as e: 
            return e 
 
As you can see from this example those exceptions are callable WSGI 
applications. However, they are not Werkzeug response objects. You 
can get a response object by calling ``get_response()`` on a HTTP 
exception. 
 
Keep in mind that you may have to pass an environ (WSGI) or scope 
(ASGI) to ``get_response()`` because some errors fetch additional 
information relating to the request. 
 
If you want to hook in a different exception page to say, a 404 status 
code, you can add a second except for a specific subclass of an error: 
 
.. code-block:: python 
 
    @Request.application 
    def application(request): 
        try: 
            return view(request) 
        except NotFound as e: 
            return not_found(request) 
        except HTTPException as e: 
            return e 
 
&quot;&quot;&quot;</span>
<span class="s2">import </span><span class="s1">sys</span>
<span class="s2">import </span><span class="s1">typing </span><span class="s2">as </span><span class="s1">t</span>
<span class="s2">import </span><span class="s1">warnings</span>
<span class="s2">from </span><span class="s1">datetime </span><span class="s2">import </span><span class="s1">datetime</span>
<span class="s2">from </span><span class="s1">html </span><span class="s2">import </span><span class="s1">escape</span>

<span class="s2">from </span><span class="s1">._internal </span><span class="s2">import </span><span class="s1">_get_environ</span>

<span class="s2">if </span><span class="s1">t.TYPE_CHECKING:</span>
    <span class="s2">import </span><span class="s1">typing_extensions </span><span class="s2">as </span><span class="s1">te</span>
    <span class="s2">from </span><span class="s1">_typeshed.wsgi </span><span class="s2">import </span><span class="s1">StartResponse</span>
    <span class="s2">from </span><span class="s1">_typeshed.wsgi </span><span class="s2">import </span><span class="s1">WSGIEnvironment</span>
    <span class="s2">from </span><span class="s1">.datastructures </span><span class="s2">import </span><span class="s1">WWWAuthenticate</span>
    <span class="s2">from </span><span class="s1">.sansio.response </span><span class="s2">import </span><span class="s1">Response</span>
    <span class="s2">from </span><span class="s1">.wrappers.response </span><span class="s2">import </span><span class="s1">Response </span><span class="s2">as </span><span class="s1">WSGIResponse  </span><span class="s3"># noqa: F401</span>


<span class="s2">class </span><span class="s1">HTTPException(Exception):</span>
    <span class="s0">&quot;&quot;&quot;The base class for all HTTP exceptions. This exception can be called as a WSGI 
    application to render a default error page or you can catch the subclasses 
    of it independently and render nicer error messages. 
    &quot;&quot;&quot;</span>

    <span class="s1">code: t.Optional[int] = </span><span class="s2">None</span>
    <span class="s1">description: t.Optional[str] = </span><span class="s2">None</span>

    <span class="s2">def </span><span class="s1">__init__(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s1">description: t.Optional[str] = </span><span class="s2">None,</span>
        <span class="s1">response: t.Optional[</span><span class="s4">&quot;Response&quot;</span><span class="s1">] = </span><span class="s2">None,</span>
    <span class="s1">) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s1">super().__init__()</span>
        <span class="s2">if </span><span class="s1">description </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">self.description = description</span>
        <span class="s1">self.response = response</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">wrap(</span>
        <span class="s1">cls</span><span class="s2">, </span><span class="s1">exception: t.Type[BaseException]</span><span class="s2">, </span><span class="s1">name: t.Optional[str] = </span><span class="s2">None</span>
    <span class="s1">) -&gt; t.Type[</span><span class="s4">&quot;HTTPException&quot;</span><span class="s1">]:</span>
        <span class="s0">&quot;&quot;&quot;Create an exception that is a subclass of the calling HTTP 
        exception and the ``exception`` argument. 
 
        The first argument to the class will be passed to the 
        wrapped ``exception``, the rest to the HTTP exception. If 
        ``e.args`` is not empty and ``e.show_exception`` is ``True``, 
        the wrapped exception message is added to the HTTP error 
        description. 
 
        .. deprecated:: 2.0 
            Will be removed in Werkzeug 2.1. Create a subclass manually 
            instead. 
 
        .. versionchanged:: 0.15.5 
            The ``show_exception`` attribute controls whether the 
            description includes the wrapped exception message. 
 
        .. versionchanged:: 0.15.0 
            The description includes the wrapped exception message. 
        &quot;&quot;&quot;</span>
        <span class="s1">warnings.warn(</span>
            <span class="s4">&quot;'HTTPException.wrap' is deprecated and will be removed in&quot;</span>
            <span class="s4">&quot; Werkzeug 2.1. Create a subclass manually instead.&quot;</span><span class="s2">,</span>
            <span class="s1">DeprecationWarning</span><span class="s2">,</span>
            <span class="s1">stacklevel=</span><span class="s5">2</span><span class="s2">,</span>
        <span class="s1">)</span>

        <span class="s2">class </span><span class="s1">newcls(cls</span><span class="s2">, </span><span class="s1">exception):  </span><span class="s3"># type: ignore</span>
            <span class="s1">_description = cls.description</span>
            <span class="s1">show_exception = </span><span class="s2">False</span>

            <span class="s2">def </span><span class="s1">__init__(</span>
                <span class="s1">self</span><span class="s2">, </span><span class="s1">arg: t.Optional[t.Any] = </span><span class="s2">None, </span><span class="s1">*args: t.Any</span><span class="s2">, </span><span class="s1">**kwargs: t.Any</span>
            <span class="s1">) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
                <span class="s1">super().__init__(*args</span><span class="s2">, </span><span class="s1">**kwargs)</span>

                <span class="s2">if </span><span class="s1">arg </span><span class="s2">is None</span><span class="s1">:</span>
                    <span class="s1">exception.__init__(self)</span>
                <span class="s2">else</span><span class="s1">:</span>
                    <span class="s1">exception.__init__(self</span><span class="s2">, </span><span class="s1">arg)</span>

            <span class="s1">@property</span>
            <span class="s2">def </span><span class="s1">description(self) -&gt; str:</span>
                <span class="s2">if </span><span class="s1">self.show_exception:</span>
                    <span class="s2">return </span><span class="s1">(</span>
                        <span class="s4">f&quot;</span><span class="s2">{</span><span class="s1">self._description</span><span class="s2">}\n</span><span class="s4">&quot;</span>
                        <span class="s4">f&quot;</span><span class="s2">{</span><span class="s1">exception.__name__</span><span class="s2">}</span><span class="s4">: </span><span class="s2">{</span><span class="s1">exception.__str__(self)</span><span class="s2">}</span><span class="s4">&quot;</span>
                    <span class="s1">)</span>

                <span class="s2">return </span><span class="s1">self._description  </span><span class="s3"># type: ignore</span>

            <span class="s1">@description.setter</span>
            <span class="s2">def </span><span class="s1">description(self</span><span class="s2">, </span><span class="s1">value: str) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
                <span class="s1">self._description = value</span>

        <span class="s1">newcls.__module__ = sys._getframe(</span><span class="s5">1</span><span class="s1">).f_globals[</span><span class="s4">&quot;__name__&quot;</span><span class="s1">]</span>
        <span class="s1">name = name </span><span class="s2">or </span><span class="s1">cls.__name__ + exception.__name__</span>
        <span class="s1">newcls.__name__ = newcls.__qualname__ = name</span>
        <span class="s2">return </span><span class="s1">newcls</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">name(self) -&gt; str:</span>
        <span class="s0">&quot;&quot;&quot;The status name.&quot;&quot;&quot;</span>
        <span class="s2">from </span><span class="s1">.http </span><span class="s2">import </span><span class="s1">HTTP_STATUS_CODES</span>

        <span class="s2">return </span><span class="s1">HTTP_STATUS_CODES.get(self.code</span><span class="s2">, </span><span class="s4">&quot;Unknown Error&quot;</span><span class="s1">)  </span><span class="s3"># type: ignore</span>

    <span class="s2">def </span><span class="s1">get_description(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s1">environ: t.Optional[</span><span class="s4">&quot;WSGIEnvironment&quot;</span><span class="s1">] = </span><span class="s2">None,</span>
        <span class="s1">scope: t.Optional[dict] = </span><span class="s2">None,</span>
    <span class="s1">) -&gt; str:</span>
        <span class="s0">&quot;&quot;&quot;Get the description.&quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">self.description </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">description = </span><span class="s4">&quot;&quot;</span>
        <span class="s2">elif not </span><span class="s1">isinstance(self.description</span><span class="s2">, </span><span class="s1">str):</span>
            <span class="s1">description = str(self.description)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">description = self.description</span>

        <span class="s1">description = escape(description).replace(</span><span class="s4">&quot;</span><span class="s2">\n</span><span class="s4">&quot;</span><span class="s2">, </span><span class="s4">&quot;&lt;br&gt;&quot;</span><span class="s1">)</span>
        <span class="s2">return </span><span class="s4">f&quot;&lt;p&gt;</span><span class="s2">{</span><span class="s1">description</span><span class="s2">}</span><span class="s4">&lt;/p&gt;&quot;</span>

    <span class="s2">def </span><span class="s1">get_body(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s1">environ: t.Optional[</span><span class="s4">&quot;WSGIEnvironment&quot;</span><span class="s1">] = </span><span class="s2">None,</span>
        <span class="s1">scope: t.Optional[dict] = </span><span class="s2">None,</span>
    <span class="s1">) -&gt; str:</span>
        <span class="s0">&quot;&quot;&quot;Get the HTML body.&quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">(</span>
            <span class="s4">'&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 3.2 Final//EN&quot;&gt;</span><span class="s2">\n</span><span class="s4">'</span>
            <span class="s4">f&quot;&lt;title&gt;</span><span class="s2">{</span><span class="s1">self.code</span><span class="s2">} {</span><span class="s1">escape(self.name)</span><span class="s2">}</span><span class="s4">&lt;/title&gt;</span><span class="s2">\n</span><span class="s4">&quot;</span>
            <span class="s4">f&quot;&lt;h1&gt;</span><span class="s2">{</span><span class="s1">escape(self.name)</span><span class="s2">}</span><span class="s4">&lt;/h1&gt;</span><span class="s2">\n</span><span class="s4">&quot;</span>
            <span class="s4">f&quot;</span><span class="s2">{</span><span class="s1">self.get_description(environ)</span><span class="s2">}\n</span><span class="s4">&quot;</span>
        <span class="s1">)</span>

    <span class="s2">def </span><span class="s1">get_headers(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s1">environ: t.Optional[</span><span class="s4">&quot;WSGIEnvironment&quot;</span><span class="s1">] = </span><span class="s2">None,</span>
        <span class="s1">scope: t.Optional[dict] = </span><span class="s2">None,</span>
    <span class="s1">) -&gt; t.List[t.Tuple[str</span><span class="s2">, </span><span class="s1">str]]:</span>
        <span class="s0">&quot;&quot;&quot;Get a list of headers.&quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">[(</span><span class="s4">&quot;Content-Type&quot;</span><span class="s2">, </span><span class="s4">&quot;text/html; charset=utf-8&quot;</span><span class="s1">)]</span>

    <span class="s2">def </span><span class="s1">get_response(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s1">environ: t.Optional[</span><span class="s4">&quot;WSGIEnvironment&quot;</span><span class="s1">] = </span><span class="s2">None,</span>
        <span class="s1">scope: t.Optional[dict] = </span><span class="s2">None,</span>
    <span class="s1">) -&gt; </span><span class="s4">&quot;Response&quot;</span><span class="s1">:</span>
        <span class="s0">&quot;&quot;&quot;Get a response object.  If one was passed to the exception 
        it's returned directly. 
 
        :param environ: the optional environ for the request.  This 
                        can be used to modify the response depending 
                        on how the request looked like. 
        :return: a :class:`Response` object or a subclass thereof. 
        &quot;&quot;&quot;</span>
        <span class="s2">from </span><span class="s1">.wrappers.response </span><span class="s2">import </span><span class="s1">Response </span><span class="s2">as </span><span class="s1">WSGIResponse  </span><span class="s3"># noqa: F811</span>

        <span class="s2">if </span><span class="s1">self.response </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">self.response</span>
        <span class="s2">if </span><span class="s1">environ </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">environ = _get_environ(environ)</span>
        <span class="s1">headers = self.get_headers(environ</span><span class="s2">, </span><span class="s1">scope)</span>
        <span class="s2">return </span><span class="s1">WSGIResponse(self.get_body(environ</span><span class="s2">, </span><span class="s1">scope)</span><span class="s2">, </span><span class="s1">self.code</span><span class="s2">, </span><span class="s1">headers)</span>

    <span class="s2">def </span><span class="s1">__call__(</span>
        <span class="s1">self</span><span class="s2">, </span><span class="s1">environ: </span><span class="s4">&quot;WSGIEnvironment&quot;</span><span class="s2">, </span><span class="s1">start_response: </span><span class="s4">&quot;StartResponse&quot;</span>
    <span class="s1">) -&gt; t.Iterable[bytes]:</span>
        <span class="s0">&quot;&quot;&quot;Call the exception as WSGI application. 
 
        :param environ: the WSGI environment. 
        :param start_response: the response callable provided by the WSGI 
                               server. 
        &quot;&quot;&quot;</span>
        <span class="s1">response = t.cast(</span><span class="s4">&quot;WSGIResponse&quot;</span><span class="s2">, </span><span class="s1">self.get_response(environ))</span>
        <span class="s2">return </span><span class="s1">response(environ</span><span class="s2">, </span><span class="s1">start_response)</span>

    <span class="s2">def </span><span class="s1">__str__(self) -&gt; str:</span>
        <span class="s1">code = self.code </span><span class="s2">if </span><span class="s1">self.code </span><span class="s2">is not None else </span><span class="s4">&quot;???&quot;</span>
        <span class="s2">return </span><span class="s4">f&quot;</span><span class="s2">{</span><span class="s1">code</span><span class="s2">} {</span><span class="s1">self.name</span><span class="s2">}</span><span class="s4">: </span><span class="s2">{</span><span class="s1">self.description</span><span class="s2">}</span><span class="s4">&quot;</span>

    <span class="s2">def </span><span class="s1">__repr__(self) -&gt; str:</span>
        <span class="s1">code = self.code </span><span class="s2">if </span><span class="s1">self.code </span><span class="s2">is not None else </span><span class="s4">&quot;???&quot;</span>
        <span class="s2">return </span><span class="s4">f&quot;&lt;</span><span class="s2">{</span><span class="s1">type(self).__name__</span><span class="s2">} </span><span class="s4">'</span><span class="s2">{</span><span class="s1">code</span><span class="s2">}</span><span class="s4">: </span><span class="s2">{</span><span class="s1">self.name</span><span class="s2">}</span><span class="s4">'&gt;&quot;</span>


<span class="s2">class </span><span class="s1">BadRequest(HTTPException):</span>
    <span class="s0">&quot;&quot;&quot;*400* `Bad Request` 
 
    Raise if the browser sends something to the application the application 
    or server cannot handle. 
    &quot;&quot;&quot;</span>

    <span class="s1">code = </span><span class="s5">400</span>
    <span class="s1">description = (</span>
        <span class="s4">&quot;The browser (or proxy) sent a request that this server could &quot;</span>
        <span class="s4">&quot;not understand.&quot;</span>
    <span class="s1">)</span>


<span class="s2">class </span><span class="s1">BadRequestKeyError(BadRequest</span><span class="s2">, </span><span class="s1">KeyError):</span>
    <span class="s0">&quot;&quot;&quot;An exception that is used to signal both a :exc:`KeyError` and a 
    :exc:`BadRequest`. Used by many of the datastructures. 
    &quot;&quot;&quot;</span>

    <span class="s1">_description = BadRequest.description</span>
    <span class="s3">#: Show the KeyError along with the HTTP error message in the</span>
    <span class="s3">#: response. This should be disabled in production, but can be</span>
    <span class="s3">#: useful in a debug mode.</span>
    <span class="s1">show_exception = </span><span class="s2">False</span>

    <span class="s2">def </span><span class="s1">__init__(self</span><span class="s2">, </span><span class="s1">arg: t.Optional[str] = </span><span class="s2">None, </span><span class="s1">*args: t.Any</span><span class="s2">, </span><span class="s1">**kwargs: t.Any):</span>
        <span class="s1">super().__init__(*args</span><span class="s2">, </span><span class="s1">**kwargs)</span>

        <span class="s2">if </span><span class="s1">arg </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">KeyError.__init__(self)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">KeyError.__init__(self</span><span class="s2">, </span><span class="s1">arg)</span>

    <span class="s1">@property  </span><span class="s3"># type: ignore</span>
    <span class="s2">def </span><span class="s1">description(self) -&gt; str:  </span><span class="s3"># type: ignore</span>
        <span class="s2">if </span><span class="s1">self.show_exception:</span>
            <span class="s2">return </span><span class="s1">(</span>
                <span class="s4">f&quot;</span><span class="s2">{</span><span class="s1">self._description</span><span class="s2">}\n</span><span class="s4">&quot;</span>
                <span class="s4">f&quot;</span><span class="s2">{</span><span class="s1">KeyError.__name__</span><span class="s2">}</span><span class="s4">: </span><span class="s2">{</span><span class="s1">KeyError.__str__(self)</span><span class="s2">}</span><span class="s4">&quot;</span>
            <span class="s1">)</span>

        <span class="s2">return </span><span class="s1">self._description</span>

    <span class="s1">@description.setter</span>
    <span class="s2">def </span><span class="s1">description(self</span><span class="s2">, </span><span class="s1">value: str) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s1">self._description = value</span>


<span class="s2">class </span><span class="s1">ClientDisconnected(BadRequest):</span>
    <span class="s0">&quot;&quot;&quot;Internal exception that is raised if Werkzeug detects a disconnected 
    client.  Since the client is already gone at that point attempting to 
    send the error message to the client might not work and might ultimately 
    result in another exception in the server.  Mainly this is here so that 
    it is silenced by default as far as Werkzeug is concerned. 
 
    Since disconnections cannot be reliably detected and are unspecified 
    by WSGI to a large extent this might or might not be raised if a client 
    is gone. 
 
    .. versionadded:: 0.8 
    &quot;&quot;&quot;</span>


<span class="s2">class </span><span class="s1">SecurityError(BadRequest):</span>
    <span class="s0">&quot;&quot;&quot;Raised if something triggers a security error.  This is otherwise 
    exactly like a bad request error. 
 
    .. versionadded:: 0.9 
    &quot;&quot;&quot;</span>


<span class="s2">class </span><span class="s1">BadHost(BadRequest):</span>
    <span class="s0">&quot;&quot;&quot;Raised if the submitted host is badly formatted. 
 
    .. versionadded:: 0.11.2 
    &quot;&quot;&quot;</span>


<span class="s2">class </span><span class="s1">Unauthorized(HTTPException):</span>
    <span class="s0">&quot;&quot;&quot;*401* ``Unauthorized`` 
 
    Raise if the user is not authorized to access a resource. 
 
    The ``www_authenticate`` argument should be used to set the 
    ``WWW-Authenticate`` header. This is used for HTTP basic auth and 
    other schemes. Use :class:`~werkzeug.datastructures.WWWAuthenticate` 
    to create correctly formatted values. Strictly speaking a 401 
    response is invalid if it doesn't provide at least one value for 
    this header, although real clients typically don't care. 
 
    :param description: Override the default message used for the body 
        of the response. 
    :param www-authenticate: A single value, or list of values, for the 
        WWW-Authenticate header(s). 
 
    .. versionchanged:: 2.0 
        Serialize multiple ``www_authenticate`` items into multiple 
        ``WWW-Authenticate`` headers, rather than joining them 
        into a single value, for better interoperability. 
 
    .. versionchanged:: 0.15.3 
        If the ``www_authenticate`` argument is not set, the 
        ``WWW-Authenticate`` header is not set. 
 
    .. versionchanged:: 0.15.3 
        The ``response`` argument was restored. 
 
    .. versionchanged:: 0.15.1 
        ``description`` was moved back as the first argument, restoring 
         its previous position. 
 
    .. versionchanged:: 0.15.0 
        ``www_authenticate`` was added as the first argument, ahead of 
        ``description``. 
    &quot;&quot;&quot;</span>

    <span class="s1">code = </span><span class="s5">401</span>
    <span class="s1">description = (</span>
        <span class="s4">&quot;The server could not verify that you are authorized to access&quot;</span>
        <span class="s4">&quot; the URL requested. You either supplied the wrong credentials&quot;</span>
        <span class="s4">&quot; (e.g. a bad password), or your browser doesn't understand&quot;</span>
        <span class="s4">&quot; how to supply the credentials required.&quot;</span>
    <span class="s1">)</span>

    <span class="s2">def </span><span class="s1">__init__(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s1">description: t.Optional[str] = </span><span class="s2">None,</span>
        <span class="s1">response: t.Optional[</span><span class="s4">&quot;Response&quot;</span><span class="s1">] = </span><span class="s2">None,</span>
        <span class="s1">www_authenticate: t.Optional[</span>
            <span class="s1">t.Union[</span><span class="s4">&quot;WWWAuthenticate&quot;</span><span class="s2">, </span><span class="s1">t.Iterable[</span><span class="s4">&quot;WWWAuthenticate&quot;</span><span class="s1">]]</span>
        <span class="s1">] = </span><span class="s2">None,</span>
    <span class="s1">) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s1">super().__init__(description</span><span class="s2">, </span><span class="s1">response)</span>

        <span class="s2">from </span><span class="s1">.datastructures </span><span class="s2">import </span><span class="s1">WWWAuthenticate</span>

        <span class="s2">if </span><span class="s1">isinstance(www_authenticate</span><span class="s2">, </span><span class="s1">WWWAuthenticate):</span>
            <span class="s1">www_authenticate = (www_authenticate</span><span class="s2">,</span><span class="s1">)</span>

        <span class="s1">self.www_authenticate = www_authenticate</span>

    <span class="s2">def </span><span class="s1">get_headers(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s1">environ: t.Optional[</span><span class="s4">&quot;WSGIEnvironment&quot;</span><span class="s1">] = </span><span class="s2">None,</span>
        <span class="s1">scope: t.Optional[dict] = </span><span class="s2">None,</span>
    <span class="s1">) -&gt; t.List[t.Tuple[str</span><span class="s2">, </span><span class="s1">str]]:</span>
        <span class="s1">headers = super().get_headers(environ</span><span class="s2">, </span><span class="s1">scope)</span>
        <span class="s2">if </span><span class="s1">self.www_authenticate:</span>
            <span class="s1">headers.extend((</span><span class="s4">&quot;WWW-Authenticate&quot;</span><span class="s2">, </span><span class="s1">str(x)) </span><span class="s2">for </span><span class="s1">x </span><span class="s2">in </span><span class="s1">self.www_authenticate)</span>
        <span class="s2">return </span><span class="s1">headers</span>


<span class="s2">class </span><span class="s1">Forbidden(HTTPException):</span>
    <span class="s0">&quot;&quot;&quot;*403* `Forbidden` 
 
    Raise if the user doesn't have the permission for the requested resource 
    but was authenticated. 
    &quot;&quot;&quot;</span>

    <span class="s1">code = </span><span class="s5">403</span>
    <span class="s1">description = (</span>
        <span class="s4">&quot;You don't have the permission to access the requested&quot;</span>
        <span class="s4">&quot; resource. It is either read-protected or not readable by the&quot;</span>
        <span class="s4">&quot; server.&quot;</span>
    <span class="s1">)</span>


<span class="s2">class </span><span class="s1">NotFound(HTTPException):</span>
    <span class="s0">&quot;&quot;&quot;*404* `Not Found` 
 
    Raise if a resource does not exist and never existed. 
    &quot;&quot;&quot;</span>

    <span class="s1">code = </span><span class="s5">404</span>
    <span class="s1">description = (</span>
        <span class="s4">&quot;The requested URL was not found on the server. If you entered&quot;</span>
        <span class="s4">&quot; the URL manually please check your spelling and try again.&quot;</span>
    <span class="s1">)</span>


<span class="s2">class </span><span class="s1">MethodNotAllowed(HTTPException):</span>
    <span class="s0">&quot;&quot;&quot;*405* `Method Not Allowed` 
 
    Raise if the server used a method the resource does not handle.  For 
    example `POST` if the resource is view only.  Especially useful for REST. 
 
    The first argument for this exception should be a list of allowed methods. 
    Strictly speaking the response would be invalid if you don't provide valid 
    methods in the header which you can do with that list. 
    &quot;&quot;&quot;</span>

    <span class="s1">code = </span><span class="s5">405</span>
    <span class="s1">description = </span><span class="s4">&quot;The method is not allowed for the requested URL.&quot;</span>

    <span class="s2">def </span><span class="s1">__init__(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s1">valid_methods: t.Optional[t.Iterable[str]] = </span><span class="s2">None,</span>
        <span class="s1">description: t.Optional[str] = </span><span class="s2">None,</span>
        <span class="s1">response: t.Optional[</span><span class="s4">&quot;Response&quot;</span><span class="s1">] = </span><span class="s2">None,</span>
    <span class="s1">) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s0">&quot;&quot;&quot;Takes an optional list of valid http methods 
        starting with werkzeug 0.3 the list will be mandatory.&quot;&quot;&quot;</span>
        <span class="s1">super().__init__(description=description</span><span class="s2">, </span><span class="s1">response=response)</span>
        <span class="s1">self.valid_methods = valid_methods</span>

    <span class="s2">def </span><span class="s1">get_headers(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s1">environ: t.Optional[</span><span class="s4">&quot;WSGIEnvironment&quot;</span><span class="s1">] = </span><span class="s2">None,</span>
        <span class="s1">scope: t.Optional[dict] = </span><span class="s2">None,</span>
    <span class="s1">) -&gt; t.List[t.Tuple[str</span><span class="s2">, </span><span class="s1">str]]:</span>
        <span class="s1">headers = super().get_headers(environ</span><span class="s2">, </span><span class="s1">scope)</span>
        <span class="s2">if </span><span class="s1">self.valid_methods:</span>
            <span class="s1">headers.append((</span><span class="s4">&quot;Allow&quot;</span><span class="s2">, </span><span class="s4">&quot;, &quot;</span><span class="s1">.join(self.valid_methods)))</span>
        <span class="s2">return </span><span class="s1">headers</span>


<span class="s2">class </span><span class="s1">NotAcceptable(HTTPException):</span>
    <span class="s0">&quot;&quot;&quot;*406* `Not Acceptable` 
 
    Raise if the server can't return any content conforming to the 
    `Accept` headers of the client. 
    &quot;&quot;&quot;</span>

    <span class="s1">code = </span><span class="s5">406</span>
    <span class="s1">description = (</span>
        <span class="s4">&quot;The resource identified by the request is only capable of&quot;</span>
        <span class="s4">&quot; generating response entities which have content&quot;</span>
        <span class="s4">&quot; characteristics not acceptable according to the accept&quot;</span>
        <span class="s4">&quot; headers sent in the request.&quot;</span>
    <span class="s1">)</span>


<span class="s2">class </span><span class="s1">RequestTimeout(HTTPException):</span>
    <span class="s0">&quot;&quot;&quot;*408* `Request Timeout` 
 
    Raise to signalize a timeout. 
    &quot;&quot;&quot;</span>

    <span class="s1">code = </span><span class="s5">408</span>
    <span class="s1">description = (</span>
        <span class="s4">&quot;The server closed the network connection because the browser&quot;</span>
        <span class="s4">&quot; didn't finish the request within the specified time.&quot;</span>
    <span class="s1">)</span>


<span class="s2">class </span><span class="s1">Conflict(HTTPException):</span>
    <span class="s0">&quot;&quot;&quot;*409* `Conflict` 
 
    Raise to signal that a request cannot be completed because it conflicts 
    with the current state on the server. 
 
    .. versionadded:: 0.7 
    &quot;&quot;&quot;</span>

    <span class="s1">code = </span><span class="s5">409</span>
    <span class="s1">description = (</span>
        <span class="s4">&quot;A conflict happened while processing the request. The&quot;</span>
        <span class="s4">&quot; resource might have been modified while the request was being&quot;</span>
        <span class="s4">&quot; processed.&quot;</span>
    <span class="s1">)</span>


<span class="s2">class </span><span class="s1">Gone(HTTPException):</span>
    <span class="s0">&quot;&quot;&quot;*410* `Gone` 
 
    Raise if a resource existed previously and went away without new location. 
    &quot;&quot;&quot;</span>

    <span class="s1">code = </span><span class="s5">410</span>
    <span class="s1">description = (</span>
        <span class="s4">&quot;The requested URL is no longer available on this server and&quot;</span>
        <span class="s4">&quot; there is no forwarding address. If you followed a link from a&quot;</span>
        <span class="s4">&quot; foreign page, please contact the author of this page.&quot;</span>
    <span class="s1">)</span>


<span class="s2">class </span><span class="s1">LengthRequired(HTTPException):</span>
    <span class="s0">&quot;&quot;&quot;*411* `Length Required` 
 
    Raise if the browser submitted data but no ``Content-Length`` header which 
    is required for the kind of processing the server does. 
    &quot;&quot;&quot;</span>

    <span class="s1">code = </span><span class="s5">411</span>
    <span class="s1">description = (</span>
        <span class="s4">&quot;A request with this method requires a valid &lt;code&gt;Content-&quot;</span>
        <span class="s4">&quot;Length&lt;/code&gt; header.&quot;</span>
    <span class="s1">)</span>


<span class="s2">class </span><span class="s1">PreconditionFailed(HTTPException):</span>
    <span class="s0">&quot;&quot;&quot;*412* `Precondition Failed` 
 
    Status code used in combination with ``If-Match``, ``If-None-Match``, or 
    ``If-Unmodified-Since``. 
    &quot;&quot;&quot;</span>

    <span class="s1">code = </span><span class="s5">412</span>
    <span class="s1">description = (</span>
        <span class="s4">&quot;The precondition on the request for the URL failed positive evaluation.&quot;</span>
    <span class="s1">)</span>


<span class="s2">class </span><span class="s1">RequestEntityTooLarge(HTTPException):</span>
    <span class="s0">&quot;&quot;&quot;*413* `Request Entity Too Large` 
 
    The status code one should return if the data submitted exceeded a given 
    limit. 
    &quot;&quot;&quot;</span>

    <span class="s1">code = </span><span class="s5">413</span>
    <span class="s1">description = </span><span class="s4">&quot;The data value transmitted exceeds the capacity limit.&quot;</span>


<span class="s2">class </span><span class="s1">RequestURITooLarge(HTTPException):</span>
    <span class="s0">&quot;&quot;&quot;*414* `Request URI Too Large` 
 
    Like *413* but for too long URLs. 
    &quot;&quot;&quot;</span>

    <span class="s1">code = </span><span class="s5">414</span>
    <span class="s1">description = (</span>
        <span class="s4">&quot;The length of the requested URL exceeds the capacity limit for&quot;</span>
        <span class="s4">&quot; this server. The request cannot be processed.&quot;</span>
    <span class="s1">)</span>


<span class="s2">class </span><span class="s1">UnsupportedMediaType(HTTPException):</span>
    <span class="s0">&quot;&quot;&quot;*415* `Unsupported Media Type` 
 
    The status code returned if the server is unable to handle the media type 
    the client transmitted. 
    &quot;&quot;&quot;</span>

    <span class="s1">code = </span><span class="s5">415</span>
    <span class="s1">description = (</span>
        <span class="s4">&quot;The server does not support the media type transmitted in the request.&quot;</span>
    <span class="s1">)</span>


<span class="s2">class </span><span class="s1">RequestedRangeNotSatisfiable(HTTPException):</span>
    <span class="s0">&quot;&quot;&quot;*416* `Requested Range Not Satisfiable` 
 
    The client asked for an invalid part of the file. 
 
    .. versionadded:: 0.7 
    &quot;&quot;&quot;</span>

    <span class="s1">code = </span><span class="s5">416</span>
    <span class="s1">description = </span><span class="s4">&quot;The server cannot provide the requested range.&quot;</span>

    <span class="s2">def </span><span class="s1">__init__(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s1">length: t.Optional[int] = </span><span class="s2">None,</span>
        <span class="s1">units: str = </span><span class="s4">&quot;bytes&quot;</span><span class="s2">,</span>
        <span class="s1">description: t.Optional[str] = </span><span class="s2">None,</span>
        <span class="s1">response: t.Optional[</span><span class="s4">&quot;Response&quot;</span><span class="s1">] = </span><span class="s2">None,</span>
    <span class="s1">) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s0">&quot;&quot;&quot;Takes an optional `Content-Range` header value based on ``length`` 
        parameter. 
        &quot;&quot;&quot;</span>
        <span class="s1">super().__init__(description=description</span><span class="s2">, </span><span class="s1">response=response)</span>
        <span class="s1">self.length = length</span>
        <span class="s1">self.units = units</span>

    <span class="s2">def </span><span class="s1">get_headers(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s1">environ: t.Optional[</span><span class="s4">&quot;WSGIEnvironment&quot;</span><span class="s1">] = </span><span class="s2">None,</span>
        <span class="s1">scope: t.Optional[dict] = </span><span class="s2">None,</span>
    <span class="s1">) -&gt; t.List[t.Tuple[str</span><span class="s2">, </span><span class="s1">str]]:</span>
        <span class="s1">headers = super().get_headers(environ</span><span class="s2">, </span><span class="s1">scope)</span>
        <span class="s2">if </span><span class="s1">self.length </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">headers.append((</span><span class="s4">&quot;Content-Range&quot;</span><span class="s2">, </span><span class="s4">f&quot;</span><span class="s2">{</span><span class="s1">self.units</span><span class="s2">} </span><span class="s4">*/</span><span class="s2">{</span><span class="s1">self.length</span><span class="s2">}</span><span class="s4">&quot;</span><span class="s1">))</span>
        <span class="s2">return </span><span class="s1">headers</span>


<span class="s2">class </span><span class="s1">ExpectationFailed(HTTPException):</span>
    <span class="s0">&quot;&quot;&quot;*417* `Expectation Failed` 
 
    The server cannot meet the requirements of the Expect request-header. 
 
    .. versionadded:: 0.7 
    &quot;&quot;&quot;</span>

    <span class="s1">code = </span><span class="s5">417</span>
    <span class="s1">description = </span><span class="s4">&quot;The server could not meet the requirements of the Expect header&quot;</span>


<span class="s2">class </span><span class="s1">ImATeapot(HTTPException):</span>
    <span class="s0">&quot;&quot;&quot;*418* `I'm a teapot` 
 
    The server should return this if it is a teapot and someone attempted 
    to brew coffee with it. 
 
    .. versionadded:: 0.7 
    &quot;&quot;&quot;</span>

    <span class="s1">code = </span><span class="s5">418</span>
    <span class="s1">description = </span><span class="s4">&quot;This server is a teapot, not a coffee machine&quot;</span>


<span class="s2">class </span><span class="s1">UnprocessableEntity(HTTPException):</span>
    <span class="s0">&quot;&quot;&quot;*422* `Unprocessable Entity` 
 
    Used if the request is well formed, but the instructions are otherwise 
    incorrect. 
    &quot;&quot;&quot;</span>

    <span class="s1">code = </span><span class="s5">422</span>
    <span class="s1">description = (</span>
        <span class="s4">&quot;The request was well-formed but was unable to be followed due&quot;</span>
        <span class="s4">&quot; to semantic errors.&quot;</span>
    <span class="s1">)</span>


<span class="s2">class </span><span class="s1">Locked(HTTPException):</span>
    <span class="s0">&quot;&quot;&quot;*423* `Locked` 
 
    Used if the resource that is being accessed is locked. 
    &quot;&quot;&quot;</span>

    <span class="s1">code = </span><span class="s5">423</span>
    <span class="s1">description = </span><span class="s4">&quot;The resource that is being accessed is locked.&quot;</span>


<span class="s2">class </span><span class="s1">FailedDependency(HTTPException):</span>
    <span class="s0">&quot;&quot;&quot;*424* `Failed Dependency` 
 
    Used if the method could not be performed on the resource 
    because the requested action depended on another action and that action failed. 
    &quot;&quot;&quot;</span>

    <span class="s1">code = </span><span class="s5">424</span>
    <span class="s1">description = (</span>
        <span class="s4">&quot;The method could not be performed on the resource because the&quot;</span>
        <span class="s4">&quot; requested action depended on another action and that action&quot;</span>
        <span class="s4">&quot; failed.&quot;</span>
    <span class="s1">)</span>


<span class="s2">class </span><span class="s1">PreconditionRequired(HTTPException):</span>
    <span class="s0">&quot;&quot;&quot;*428* `Precondition Required` 
 
    The server requires this request to be conditional, typically to prevent 
    the lost update problem, which is a race condition between two or more 
    clients attempting to update a resource through PUT or DELETE. By requiring 
    each client to include a conditional header (&quot;If-Match&quot; or &quot;If-Unmodified- 
    Since&quot;) with the proper value retained from a recent GET request, the 
    server ensures that each client has at least seen the previous revision of 
    the resource. 
    &quot;&quot;&quot;</span>

    <span class="s1">code = </span><span class="s5">428</span>
    <span class="s1">description = (</span>
        <span class="s4">&quot;This request is required to be conditional; try using&quot;</span>
        <span class="s4">' &quot;If-Match&quot; or &quot;If-Unmodified-Since&quot;.'</span>
    <span class="s1">)</span>


<span class="s2">class </span><span class="s1">_RetryAfter(HTTPException):</span>
    <span class="s0">&quot;&quot;&quot;Adds an optional ``retry_after`` parameter which will set the 
    ``Retry-After`` header. May be an :class:`int` number of seconds or 
    a :class:`~datetime.datetime`. 
    &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">__init__(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s1">description: t.Optional[str] = </span><span class="s2">None,</span>
        <span class="s1">response: t.Optional[</span><span class="s4">&quot;Response&quot;</span><span class="s1">] = </span><span class="s2">None,</span>
        <span class="s1">retry_after: t.Optional[t.Union[datetime</span><span class="s2">, </span><span class="s1">int]] = </span><span class="s2">None,</span>
    <span class="s1">) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s1">super().__init__(description</span><span class="s2">, </span><span class="s1">response)</span>
        <span class="s1">self.retry_after = retry_after</span>

    <span class="s2">def </span><span class="s1">get_headers(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s1">environ: t.Optional[</span><span class="s4">&quot;WSGIEnvironment&quot;</span><span class="s1">] = </span><span class="s2">None,</span>
        <span class="s1">scope: t.Optional[dict] = </span><span class="s2">None,</span>
    <span class="s1">) -&gt; t.List[t.Tuple[str</span><span class="s2">, </span><span class="s1">str]]:</span>
        <span class="s1">headers = super().get_headers(environ</span><span class="s2">, </span><span class="s1">scope)</span>

        <span class="s2">if </span><span class="s1">self.retry_after:</span>
            <span class="s2">if </span><span class="s1">isinstance(self.retry_after</span><span class="s2">, </span><span class="s1">datetime):</span>
                <span class="s2">from </span><span class="s1">.http </span><span class="s2">import </span><span class="s1">http_date</span>

                <span class="s1">value = http_date(self.retry_after)</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">value = str(self.retry_after)</span>

            <span class="s1">headers.append((</span><span class="s4">&quot;Retry-After&quot;</span><span class="s2">, </span><span class="s1">value))</span>

        <span class="s2">return </span><span class="s1">headers</span>


<span class="s2">class </span><span class="s1">TooManyRequests(_RetryAfter):</span>
    <span class="s0">&quot;&quot;&quot;*429* `Too Many Requests` 
 
    The server is limiting the rate at which this user receives 
    responses, and this request exceeds that rate. (The server may use 
    any convenient method to identify users and their request rates). 
    The server may include a &quot;Retry-After&quot; header to indicate how long 
    the user should wait before retrying. 
 
    :param retry_after: If given, set the ``Retry-After`` header to this 
        value. May be an :class:`int` number of seconds or a 
        :class:`~datetime.datetime`. 
 
    .. versionchanged:: 1.0 
        Added ``retry_after`` parameter. 
    &quot;&quot;&quot;</span>

    <span class="s1">code = </span><span class="s5">429</span>
    <span class="s1">description = </span><span class="s4">&quot;This user has exceeded an allotted request count. Try again later.&quot;</span>


<span class="s2">class </span><span class="s1">RequestHeaderFieldsTooLarge(HTTPException):</span>
    <span class="s0">&quot;&quot;&quot;*431* `Request Header Fields Too Large` 
 
    The server refuses to process the request because the header fields are too 
    large. One or more individual fields may be too large, or the set of all 
    headers is too large. 
    &quot;&quot;&quot;</span>

    <span class="s1">code = </span><span class="s5">431</span>
    <span class="s1">description = </span><span class="s4">&quot;One or more header fields exceeds the maximum size.&quot;</span>


<span class="s2">class </span><span class="s1">UnavailableForLegalReasons(HTTPException):</span>
    <span class="s0">&quot;&quot;&quot;*451* `Unavailable For Legal Reasons` 
 
    This status code indicates that the server is denying access to the 
    resource as a consequence of a legal demand. 
    &quot;&quot;&quot;</span>

    <span class="s1">code = </span><span class="s5">451</span>
    <span class="s1">description = </span><span class="s4">&quot;Unavailable for legal reasons.&quot;</span>


<span class="s2">class </span><span class="s1">InternalServerError(HTTPException):</span>
    <span class="s0">&quot;&quot;&quot;*500* `Internal Server Error` 
 
    Raise if an internal server error occurred.  This is a good fallback if an 
    unknown error occurred in the dispatcher. 
 
    .. versionchanged:: 1.0.0 
        Added the :attr:`original_exception` attribute. 
    &quot;&quot;&quot;</span>

    <span class="s1">code = </span><span class="s5">500</span>
    <span class="s1">description = (</span>
        <span class="s4">&quot;The server encountered an internal error and was unable to&quot;</span>
        <span class="s4">&quot; complete your request. Either the server is overloaded or&quot;</span>
        <span class="s4">&quot; there is an error in the application.&quot;</span>
    <span class="s1">)</span>

    <span class="s2">def </span><span class="s1">__init__(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s1">description: t.Optional[str] = </span><span class="s2">None,</span>
        <span class="s1">response: t.Optional[</span><span class="s4">&quot;Response&quot;</span><span class="s1">] = </span><span class="s2">None,</span>
        <span class="s1">original_exception: t.Optional[BaseException] = </span><span class="s2">None,</span>
    <span class="s1">) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s3">#: The original exception that caused this 500 error. Can be</span>
        <span class="s3">#: used by frameworks to provide context when handling</span>
        <span class="s3">#: unexpected errors.</span>
        <span class="s1">self.original_exception = original_exception</span>
        <span class="s1">super().__init__(description=description</span><span class="s2">, </span><span class="s1">response=response)</span>


<span class="s2">class </span><span class="s1">NotImplemented(HTTPException):</span>
    <span class="s0">&quot;&quot;&quot;*501* `Not Implemented` 
 
    Raise if the application does not support the action requested by the 
    browser. 
    &quot;&quot;&quot;</span>

    <span class="s1">code = </span><span class="s5">501</span>
    <span class="s1">description = </span><span class="s4">&quot;The server does not support the action requested by the browser.&quot;</span>


<span class="s2">class </span><span class="s1">BadGateway(HTTPException):</span>
    <span class="s0">&quot;&quot;&quot;*502* `Bad Gateway` 
 
    If you do proxying in your application you should return this status code 
    if you received an invalid response from the upstream server it accessed 
    in attempting to fulfill the request. 
    &quot;&quot;&quot;</span>

    <span class="s1">code = </span><span class="s5">502</span>
    <span class="s1">description = (</span>
        <span class="s4">&quot;The proxy server received an invalid response from an upstream server.&quot;</span>
    <span class="s1">)</span>


<span class="s2">class </span><span class="s1">ServiceUnavailable(_RetryAfter):</span>
    <span class="s0">&quot;&quot;&quot;*503* `Service Unavailable` 
 
    Status code you should return if a service is temporarily 
    unavailable. 
 
    :param retry_after: If given, set the ``Retry-After`` header to this 
        value. May be an :class:`int` number of seconds or a 
        :class:`~datetime.datetime`. 
 
    .. versionchanged:: 1.0 
        Added ``retry_after`` parameter. 
    &quot;&quot;&quot;</span>

    <span class="s1">code = </span><span class="s5">503</span>
    <span class="s1">description = (</span>
        <span class="s4">&quot;The server is temporarily unable to service your request due&quot;</span>
        <span class="s4">&quot; to maintenance downtime or capacity problems. Please try&quot;</span>
        <span class="s4">&quot; again later.&quot;</span>
    <span class="s1">)</span>


<span class="s2">class </span><span class="s1">GatewayTimeout(HTTPException):</span>
    <span class="s0">&quot;&quot;&quot;*504* `Gateway Timeout` 
 
    Status code you should return if a connection to an upstream server 
    times out. 
    &quot;&quot;&quot;</span>

    <span class="s1">code = </span><span class="s5">504</span>
    <span class="s1">description = </span><span class="s4">&quot;The connection to an upstream server timed out.&quot;</span>


<span class="s2">class </span><span class="s1">HTTPVersionNotSupported(HTTPException):</span>
    <span class="s0">&quot;&quot;&quot;*505* `HTTP Version Not Supported` 
 
    The server does not support the HTTP protocol version used in the request. 
    &quot;&quot;&quot;</span>

    <span class="s1">code = </span><span class="s5">505</span>
    <span class="s1">description = (</span>
        <span class="s4">&quot;The server does not support the HTTP protocol version used in the request.&quot;</span>
    <span class="s1">)</span>


<span class="s1">default_exceptions: t.Dict[int</span><span class="s2">, </span><span class="s1">t.Type[HTTPException]] = {}</span>


<span class="s2">def </span><span class="s1">_find_exceptions() -&gt; </span><span class="s2">None</span><span class="s1">:</span>
    <span class="s2">for </span><span class="s1">obj </span><span class="s2">in </span><span class="s1">globals().values():</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s1">is_http_exception = issubclass(obj</span><span class="s2">, </span><span class="s1">HTTPException)</span>
        <span class="s2">except </span><span class="s1">TypeError:</span>
            <span class="s1">is_http_exception = </span><span class="s2">False</span>
        <span class="s2">if not </span><span class="s1">is_http_exception </span><span class="s2">or </span><span class="s1">obj.code </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s2">continue</span>
        <span class="s1">old_obj = default_exceptions.get(obj.code</span><span class="s2">, None</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">old_obj </span><span class="s2">is not None and </span><span class="s1">issubclass(obj</span><span class="s2">, </span><span class="s1">old_obj):</span>
            <span class="s2">continue</span>
        <span class="s1">default_exceptions[obj.code] = obj</span>


<span class="s1">_find_exceptions()</span>
<span class="s2">del </span><span class="s1">_find_exceptions</span>


<span class="s2">class </span><span class="s1">Aborter:</span>
    <span class="s0">&quot;&quot;&quot;When passed a dict of code -&gt; exception items it can be used as 
    callable that raises exceptions.  If the first argument to the 
    callable is an integer it will be looked up in the mapping, if it's 
    a WSGI application it will be raised in a proxy exception. 
 
    The rest of the arguments are forwarded to the exception constructor. 
    &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">__init__(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s1">mapping: t.Optional[t.Dict[int</span><span class="s2">, </span><span class="s1">t.Type[HTTPException]]] = </span><span class="s2">None,</span>
        <span class="s1">extra: t.Optional[t.Dict[int</span><span class="s2">, </span><span class="s1">t.Type[HTTPException]]] = </span><span class="s2">None,</span>
    <span class="s1">) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s2">if </span><span class="s1">mapping </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">mapping = default_exceptions</span>
        <span class="s1">self.mapping = dict(mapping)</span>
        <span class="s2">if </span><span class="s1">extra </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">self.mapping.update(extra)</span>

    <span class="s2">def </span><span class="s1">__call__(</span>
        <span class="s1">self</span><span class="s2">, </span><span class="s1">code: t.Union[int</span><span class="s2">, </span><span class="s4">&quot;Response&quot;</span><span class="s1">]</span><span class="s2">, </span><span class="s1">*args: t.Any</span><span class="s2">, </span><span class="s1">**kwargs: t.Any</span>
    <span class="s1">) -&gt; </span><span class="s4">&quot;te.NoReturn&quot;</span><span class="s1">:</span>
        <span class="s2">from </span><span class="s1">.sansio.response </span><span class="s2">import </span><span class="s1">Response</span>

        <span class="s2">if </span><span class="s1">isinstance(code</span><span class="s2">, </span><span class="s1">Response):</span>
            <span class="s2">raise </span><span class="s1">HTTPException(response=code)</span>

        <span class="s2">if </span><span class="s1">code </span><span class="s2">not in </span><span class="s1">self.mapping:</span>
            <span class="s2">raise </span><span class="s1">LookupError(</span><span class="s4">f&quot;no exception for </span><span class="s2">{</span><span class="s1">code</span><span class="s2">!r}</span><span class="s4">&quot;</span><span class="s1">)</span>

        <span class="s2">raise </span><span class="s1">self.mapping[code](*args</span><span class="s2">, </span><span class="s1">**kwargs)</span>


<span class="s2">def </span><span class="s1">abort(</span>
    <span class="s1">status: t.Union[int</span><span class="s2">, </span><span class="s4">&quot;Response&quot;</span><span class="s1">]</span><span class="s2">, </span><span class="s1">*args: t.Any</span><span class="s2">, </span><span class="s1">**kwargs: t.Any</span>
<span class="s1">) -&gt; </span><span class="s4">&quot;te.NoReturn&quot;</span><span class="s1">:</span>
    <span class="s0">&quot;&quot;&quot;Raises an :py:exc:`HTTPException` for the given status code or WSGI 
    application. 
 
    If a status code is given, it will be looked up in the list of 
    exceptions and will raise that exception.  If passed a WSGI application, 
    it will wrap it in a proxy WSGI exception and raise that:: 
 
       abort(404)  # 404 Not Found 
       abort(Response('Hello World')) 
 
    &quot;&quot;&quot;</span>
    <span class="s1">_aborter(status</span><span class="s2">, </span><span class="s1">*args</span><span class="s2">, </span><span class="s1">**kwargs)</span>


<span class="s1">_aborter: Aborter = Aborter()</span>
</pre>
</body>
</html>